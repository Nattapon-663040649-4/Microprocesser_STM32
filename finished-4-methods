#include <stdint.h>
#include <stdio.h>
#include <math.h>
#define STM32F411xE
#include "stm32f4xx.h"

/* --- ADC Constants --- */
#define VREF 3.3f
#define ADC_MAXRES 4095.0f
#define RX 10000.0f
#define SLOPE -0.6875f
#define OFFSET 5.1276f
#define R0 10000.0f
#define T0 298.15f
#define BETA 3950.0f

/* --- Delay --- */
static void delay(volatile uint32_t t) {
    while (t--) __NOP();
}

/* --- UART Tx String --- */
void vdg_UART_TxString(char strOut[]) {
    for (uint8_t idx = 0; strOut[idx] != '\0'; idx++) {
        while ((USART2->SR & USART_SR_TXE) == 0);
        USART2->DR = strOut[idx];
    }
}

/* --- 7-Segment Display --- */
void Display_7Seg(uint8_t number) {
    // Clear all segments first
    GPIOA->ODR &= ~((1 << 8) | (1 << 9));
    GPIOB->ODR &= ~(1 << 10);
    GPIOC->ODR &= ~(1 << 7);

    switch(number) {
        case 1: GPIOC->ODR |= (1 << 7); break;
        case 2: GPIOA->ODR |= (1 << 8); break;
        case 3: GPIOA->ODR |= (1 << 8); GPIOC->ODR |= (1 << 7); break;
        case 4: GPIOB->ODR |= (1 << 10); break;
        case 5: GPIOB->ODR |= (1 << 10); GPIOC->ODR |= (1 << 7); break;
        case 6: GPIOA->ODR |= (1 << 8); GPIOB->ODR |= (1 << 10); break;
        case 7: GPIOA->ODR |= (1 << 8); GPIOB->ODR |= (1 << 10); GPIOC->ODR |= (1 << 7); break;
        case 8: GPIOA->ODR |= (1 << 9); break;
        case 9: GPIOA->ODR |= (1 << 9); GPIOC->ODR |= (1 << 7); break;
        default: break; // 0
    }
}

int main(void) {
    char stringOut[50];

    /* --- Enable Clocks --- */
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOBEN | RCC_AHB1ENR_GPIOCEN;
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

    /* --- GPIO Config --- */
    // PA8, PA9, PB10, PC7 = 7-seg
    GPIOA->MODER &= ~(GPIO_MODER_MODER8 | GPIO_MODER_MODER9);
    GPIOA->MODER |= (1 << GPIO_MODER_MODER8_Pos) | (1 << GPIO_MODER_MODER9_Pos);
    GPIOB->MODER &= ~(GPIO_MODER_MODER10);
    GPIOB->MODER |= (1 << GPIO_MODER_MODER10_Pos);
    GPIOC->MODER &= ~(GPIO_MODER_MODER7);
    GPIOC->MODER |= (1 << GPIO_MODER_MODER7_Pos);

    // LED Pins
    GPIOA->MODER &= ~(3U << (2*6));
    GPIOA->MODER |= (1U << (2*6)); // PA6 = Red LED
    GPIOB->MODER &= ~(3U << (2*6));
    GPIOB->MODER |= (1U << (2*6)); // PB6 = Green LED
    GPIOA->MODER &= ~(3U << (2*5));
    GPIOA->MODER |= (1U << (2*5)); // PA5 = Yellow LED (Temp)
    GPIOA->MODER &= ~(3U << (2*7));
    GPIOA->MODER |= (1U << (2*7)); // PA7 = Blue LED (LDR)

    // Buttons: PA10, PB3, PB5, PB4 (input, pull-up)
    GPIOA->MODER &= ~(3U << (2*10));
    GPIOB->MODER &= ~(3U << (2*3 | 2*5 | 2*4));
    GPIOA->PUPDR |= (1U << (2*10));
    GPIOB->PUPDR |= (1U << (2*3 | 2*5 | 2*4));

    // ADC Pins: PA0 = NTC, PA1 = LDR, PA4 = Potentiometer
    GPIOA->MODER |= (3U << (2*0)) | (3U << (2*1)) | (3U << (2*4));

    /* --- ADC Config --- */
    ADC1->CR2 = 0;
    ADC1->SMPR2 |= (7 << ADC_SMPR2_SMP0_Pos) | (7 << ADC_SMPR2_SMP1_Pos) | (7 << ADC_SMPR2_SMP4_Pos);
    ADC1->SQR1 &= ~ADC_SQR1_L;
    ADC1->CR2 |= ADC_CR2_ADON;

    /* --- USART2 --- */
    GPIOA->MODER &= ~(GPIO_MODER_MODER2 | GPIO_MODER_MODER3);
    GPIOA->MODER |= (0b10 << GPIO_MODER_MODER2_Pos) | (0b10 << GPIO_MODER_MODER3_Pos);
    GPIOA->AFR[0] |= (7 << GPIO_AFRL_AFSEL2_Pos) | (7 << GPIO_AFRL_AFSEL3_Pos);
    USART2->CR1 |= USART_CR1_UE | USART_CR1_TE;
    USART2->BRR = 139; // 115200 @16MHz

    /* --- Enable FPU --- */
    SCB->CPACR |= (0b1111 << 20);
    __asm volatile("dsb");
    __asm volatile("isb");

    uint16_t adc_val = 0;
    uint8_t pot_number = 0;

    while(1) {
        // --- Read Potentiometer PA4 ---
        ADC1->SQR3 = 4;
        ADC1->CR2 |= ADC_CR2_SWSTART;
        while (!(ADC1->SR & ADC_SR_EOC));
        adc_val = ADC1->DR;

        // --- Map ADC to number 0–9 แบบหมุนตามเข็มนาฬิกา ---
        pot_number = ((4095 - adc_val) * 10) / 4096; // 0-9
        Display_7Seg(pot_number);

        // --- Read NTC PA0 ---
        ADC1->SQR3 = 0;
        ADC1->CR2 |= ADC_CR2_SWSTART;
        while (!(ADC1->SR & ADC_SR_EOC));
        float adc_voltage_ntc = (ADC1->DR * VREF) / ADC_MAXRES;
        float r_ntc = RX * adc_voltage_ntc / (VREF - adc_voltage_ntc);
        float temperature = (BETA*T0)/(T0*logf(r_ntc/R0)+BETA) - 273.15f;
        if (temperature >= 28.0f) GPIOA->BSRR = GPIO_BSRR_BS5;
        else GPIOA->BSRR = GPIO_BSRR_BR5;

        // --- Read LDR PA1 ---
        ADC1->SQR3 = 1;
        ADC1->CR2 |= ADC_CR2_SWSTART;
        while (!(ADC1->SR & ADC_SR_EOC));
        float adc_voltage_ldr = (ADC1->DR * VREF) / ADC_MAXRES;
        float r_ldr = RX * adc_voltage_ldr / (VREF - adc_voltage_ldr);
        float lightintensity = powf(10, SLOPE * log10f(r_ldr) + OFFSET);
        if (lightintensity < 300.0f) GPIOA->BSRR = GPIO_BSRR_BS7;
        else GPIOA->BSRR = GPIO_BSRR_BR7;

        // --- Read Buttons (State) ---
        uint8_t btn_D2 = (GPIOA->IDR & (1U << 10)) ? 1 : 0; // forward
        uint8_t btn_D3 = (GPIOB->IDR & (1U << 3)) ? 1 : 0;  // backward
        uint8_t btn_D4 = (GPIOB->IDR & (1U << 5)) ? 1 : 0;  // left
        uint8_t btn_D5 = (GPIOB->IDR & (1U << 4)) ? 1 : 0;  // right
        uint8_t state = ((btn_D5==0)<<3)|((btn_D4==0)<<2)|((btn_D3==0)<<1)|(btn_D2==0);

        // --- LED State Machine ---
        switch(state) {
            case 0x0: GPIOA->BSRR = GPIO_BSRR_BR6; GPIOB->BSRR = GPIO_BSRR_BR6;break;
            case 0x1: GPIOB->BSRR = GPIO_BSRR_BS6; GPIOA->BSRR = GPIO_BSRR_BR6; break;
            case 0x2: GPIOA->BSRR = GPIO_BSRR_BS6; GPIOB->BSRR = GPIO_BSRR_BR6; break;
            case 0x4: GPIOB->BSRR = GPIO_BSRR_BR6; GPIOA->BSRR = GPIO_BSRR_BS6; delay(300000); GPIOA->BSRR = GPIO_BSRR_BR6; delay(300000); break;
            case 0x8: GPIOA->BSRR = GPIO_BSRR_BR6; GPIOB->BSRR = GPIO_BSRR_BS6; delay(300000); GPIOB->BSRR = GPIO_BSRR_BR6; delay(300000); break;
            case 0x3: case 0xC: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF: GPIOA->BSRR = GPIO_BSRR_BR6; GPIOB->BSRR = GPIO_BSRR_BR6; Display_7Seg(0); break;
            case 0x5: GPIOB->BSRR = GPIO_BSRR_BS6; GPIOB->BSRR = GPIO_BSRR_BS6; delay(200000); GPIOB->BSRR = GPIO_BSRR_BR6; delay(200000); break;
            case 0x9: GPIOB->BSRR = GPIO_BSRR_BS6; GPIOA->BSRR = GPIO_BSRR_BS6; delay(200000); GPIOA->BSRR = GPIO_BSRR_BR6; delay(200000); break;
            case 0x6: GPIOA->BSRR = GPIO_BSRR_BS6; GPIOB->BSRR = GPIO_BSRR_BS6; delay(200000); GPIOB->BSRR = GPIO_BSRR_BR6; delay(200000); break;
            case 0xA: GPIOA->BSRR = GPIO_BSRR_BS6; GPIOA->BSRR = GPIO_BSRR_BS6; delay(200000); GPIOA->BSRR = GPIO_BSRR_BR6; delay(200000); break;
            default:
            	GPIOA->BSRR = GPIO_BSRR_BR6; // ดับแดง
            	GPIOB->BSRR = GPIO_BSRR_BR6;
            	Display_7Seg(0); break;
        }

        delay(50000); // small delay
    }
}

