/* main.c - เวอร์ชันรวม Hall switch (PB0) กับโค้ดเดิม
   Target: STM32F411xE
   พฤติกรรม: เริ่มต้นระบบ "ปิด" -> แม่เหล็ก HALL(PB0) ครั้งแรก -> เปิดระบบ
               -> ครั้งถัดไป -> ปิดระบบ
*/

#include <stdint.h>
#include <stdio.h>
#include <math.h>

#define STM32F411xE
#include "stm32f4xx.h"

/* --- ADC Constants --- */
#define VREF 3.3f
#define ADC_MAXRES 4095.0f
#define RX 10000.0f
#define SLOPE -0.6875f
#define OFFSET 5.1276f
#define R0 10000.0f
#define T0 298.15f
#define BETA 3950.0f

/* --- Delay --- */
static void delay(volatile uint32_t t) {
    while (t--) __NOP();
}

/* --- UART Tx String --- */
void vdg_UART_TxString(char strOut[]) {
    for (uint8_t idx = 0; strOut[idx] != '\0'; idx++) {
        while ((USART2->SR & USART_SR_TXE) == 0);
        USART2->DR = strOut[idx];
    }
}

/* --- 7-Segment Display --- */
void Display_7Seg(uint8_t number) {
    // Clear all segments first
    GPIOA->ODR &= ~((1 << 8) | (1 << 9));
    GPIOB->ODR &= ~(1 << 10);
    GPIOC->ODR &= ~(1 << 7);

    switch(number) {
        case 1: GPIOC->ODR |= (1 << 7); break;
        case 2: GPIOA->ODR |= (1 << 8); break;
        case 3: GPIOA->ODR |= (1 << 8); GPIOC->ODR |= (1 << 7); break;
        case 4: GPIOB->ODR |= (1 << 10); break;
        case 5: GPIOB->ODR |= (1 << 10); GPIOC->ODR |= (1 << 7); break;
        case 6: GPIOA->ODR |= (1 << 8); GPIOB->ODR |= (1 << 10); break;
        case 7: GPIOA->ODR |= (1 << 8); GPIOB->ODR |= (1 << 10); GPIOC->ODR |= (1 << 7); break;
        case 8: GPIOA->ODR |= (1 << 9); break;
        case 9: GPIOA->ODR |= (1 << 9); GPIOC->ODR |= (1 << 7); break;
        default: break; // 0
    }
}

int main(void) {
    char stringOut[50];

    /* --- Enable Clocks --- */
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOBEN | RCC_AHB1ENR_GPIOCEN;
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

    /* --- GPIO Config (ตามโค้ดเดิม) --- */
    GPIOA->MODER &= ~(GPIO_MODER_MODER8 | GPIO_MODER_MODER9);
    GPIOA->MODER |= (1 << GPIO_MODER_MODER8_Pos) | (1 << GPIO_MODER_MODER9_Pos);
    GPIOB->MODER &= ~(GPIO_MODER_MODER10);
    GPIOB->MODER |= (1 << GPIO_MODER_MODER10_Pos);
    GPIOC->MODER &= ~(GPIO_MODER_MODER7);
    GPIOC->MODER |= (1 << GPIO_MODER_MODER7_Pos);

    // LED Pins
    GPIOA->MODER &= ~(3U << (2*6));
    GPIOA->MODER |= (1U << (2*6)); // PA6 = Red LED
    GPIOB->MODER &= ~(3U << (2*6));
    GPIOB->MODER |= (1U << (2*6)); // PB6 = Green LED
    GPIOA->MODER &= ~(3U << (2*5));
    GPIOA->MODER |= (1U << (2*5)); // PA5 = Yellow LED
    GPIOA->MODER &= ~(3U << (2*7));
    GPIOA->MODER |= (1U << (2*7)); // PA7 = Blue LED

    // Buttons: PA10, PB3, PB5, PB4 (input, pull-up)
    GPIOA->MODER &= ~(3U << (2*10));
    GPIOB->MODER &= ~(3U << (2*3 | 2*5 | 2*4));
    GPIOA->PUPDR |= (1U << (2*10));
    GPIOB->PUPDR |= (1U << (2*3 | 2*5 | 2*4));

    // ADC Pins
    GPIOA->MODER |= (3U << (2*0)) | (3U << (2*1)) | (3U << (2*4));

    // Hall Sensor: PB0 input + pull-up
    GPIOB->MODER &= ~(3U << (2*0));
    GPIOB->PUPDR &= ~(3U << (2*0));
    GPIOB->PUPDR |= (1U << (2*0));

    /* --- ADC Config --- */
    ADC1->CR2 = 0;
    ADC1->SMPR2 |= (7 << ADC_SMPR2_SMP0_Pos) | (7 << ADC_SMPR2_SMP1_Pos) | (7 << ADC_SMPR2_SMP4_Pos);
    ADC1->SQR1 &= ~ADC_SQR1_L;
    ADC1->CR2 |= ADC_CR2_ADON;

    /* --- USART2 --- */
    GPIOA->MODER &= ~(GPIO_MODER_MODER2 | GPIO_MODER_MODER3);
    GPIOA->MODER |= (0b10 << GPIO_MODER_MODER2_Pos) | (0b10 << GPIO_MODER_MODER3_Pos);
    GPIOA->AFR[0] |= (7 << GPIO_AFRL_AFSEL2_Pos) | (7 << GPIO_AFRL_AFSEL3_Pos);
    USART2->CR1 |= USART_CR1_UE | USART_CR1_TE;
    USART2->BRR = 139; // 115200 @16MHz

    /* --- Enable FPU --- */
    SCB->CPACR |= (0b1111 << 20);
    __asm volatile("dsb");
    __asm volatile("isb");

    uint16_t adc_val = 0;
    uint8_t pot_number = 0;

    /* --- Hall control variables --- */
    uint8_t system_enabled = 0;           // 0 = system off (เริ่มต้นปิด)
    uint8_t last_hall = (GPIOB->IDR & (1U << 0)) ? 1 : 0; // อ่านค่าเริ่มต้น PB0

    /* --- Main loop --- */
    while(1) {
        /* --- ตรวจจับ Hall Sensor (edge: HIGH -> LOW) --- */
        uint8_t hall_now = (GPIOB->IDR & (1U << 0)) ? 1 : 0;
        if (last_hall == 1 && hall_now == 0) {
            system_enabled = !system_enabled;
            if (!system_enabled) {
                // ปิดไฟ LED ทั้งหมด
                GPIOA->BSRR = GPIO_BSRR_BR5 | GPIO_BSRR_BR6 | GPIO_BSRR_BR7;
                GPIOB->BSRR = GPIO_BSRR_BR6;
                // แสดง 7-seg = 0
                Display_7Seg(0);
            }
            delay(300000); // debounce
        }
        last_hall = hall_now;

        /* --- ถ้าระบบปิด ให้ข้ามการทำงานทั้งหมด --- */
        if (!system_enabled) continue;

        /* --- Read Potentiometer PA4 --- */
        ADC1->SQR3 = 4;
        ADC1->CR2 |= ADC_CR2_SWSTART;
        while (!(ADC1->SR & ADC_SR_EOC));
        adc_val = ADC1->DR;
        pot_number = ((4095 - adc_val) * 10) / 4096;

        /* --- Read Buttons --- */
        uint8_t btn_D2 = (GPIOA->IDR & (1U << 10)) ? 1 : 0; // forward
        uint8_t btn_D3 = (GPIOB->IDR & (1U << 3)) ? 1 : 0;  // backward
        uint8_t btn_D4 = (GPIOB->IDR & (1U << 5)) ? 1 : 0;  // left
        uint8_t btn_D5 = (GPIOB->IDR & (1U << 4)) ? 1 : 0;  // right

        // ถ้าไม่มีปุ่มกดใดเลย ให้ 7-segment = 0
        if (btn_D2 && btn_D3 && btn_D4 && btn_D5) {
            Display_7Seg(0);
        } else {
            Display_7Seg(pot_number);
        }

        /* --- LED State Machine (โค้ดเดิม) --- */
        uint8_t state = ((btn_D5==0)<<3)|((btn_D4==0)<<2)|((btn_D3==0)<<1)|(btn_D2==0);
        switch(state) {
            case 0x0: GPIOA->BSRR = GPIO_BSRR_BR6; GPIOB->BSRR = GPIO_BSRR_BR6; break;
            case 0x1: GPIOB->BSRR = GPIO_BSRR_BS6; GPIOA->BSRR = GPIO_BSRR_BR6; break;
            case 0x2: GPIOA->BSRR = GPIO_BSRR_BS6; GPIOB->BSRR = GPIO_BSRR_BR6; break;
            case 0x4: GPIOB->BSRR = GPIO_BSRR_BR6; GPIOA->BSRR = GPIO_BSRR_BS6; delay(300000); GPIOA->BSRR = GPIO_BSRR_BR6; delay(300000); break;
            case 0x8: GPIOA->BSRR = GPIO_BSRR_BR6; GPIOB->BSRR = GPIO_BSRR_BS6; delay(300000); GPIOB->BSRR = GPIO_BSRR_BR6; delay(300000); break;
            case 0x3: case 0xC: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF: GPIOA->BSRR = GPIO_BSRR_BR6; GPIOB->BSRR = GPIO_BSRR_BR6; Display_7Seg(0); break;
            case 0x5: GPIOB->BSRR = GPIO_BSRR_BS6; GPIOB->BSRR = GPIO_BSRR_BS6; delay(200000); GPIOB->BSRR = GPIO_BSRR_BR6; delay(200000); break;
            case 0x9: GPIOB->BSRR = GPIO_BSRR_BS6; GPIOA->BSRR = GPIO_BSRR_BS6; delay(200000); GPIOA->BSRR = GPIO_BSRR_BR6; delay(200000); break;
            case 0x6: GPIOA->BSRR = GPIO_BSRR_BS6; GPIOB->BSRR = GPIO_BSRR_BS6; delay(200000); GPIOB->BSRR = GPIO_BSRR_BR6; delay(200000); break;
            case 0xA: GPIOA->BSRR = GPIO_BSRR_BS6; GPIOA->BSRR = GPIO_BSRR_BS6; delay(200000); GPIOA->BSRR = GPIO_BSRR_BR6; delay(200000); break;
            default: GPIOA->BSRR = GPIO_BSRR_BR6; GPIOB->BSRR = GPIO_BSRR_BR6; Display_7Seg(0); break;
        }

        /* --- Read NTC PA0 --- */
        ADC1->SQR3 = 0;
        ADC1->CR2 |= ADC_CR2_SWSTART;
        while (!(ADC1->SR & ADC_SR_EOC));
        float adc_voltage_ntc = (ADC1->DR * VREF) / ADC_MAXRES;
        float r_ntc = RX * adc_voltage_ntc / (VREF - adc_voltage_ntc);
        float temperature = (BETA*T0)/(T0*logf(r_ntc/R0)+BETA) - 273.15f;
        if (temperature >= 28.0f) GPIOA->BSRR = GPIO_BSRR_BS5; else GPIOA->BSRR = GPIO_BSRR_BR5;

        /* --- Read LDR PA1 --- */
        ADC1->SQR3 = 1;
        ADC1->CR2 |= ADC_CR2_SWSTART;
        while (!(ADC1->SR & ADC_SR_EOC));
        float adc_voltage_ldr = (ADC1->DR * VREF) / ADC_MAXRES;
        float r_ldr = RX * adc_voltage_ldr / (VREF - adc_voltage_ldr);
        float lightintensity = powf(10, SLOPE * log10f(r_ldr) + OFFSET);
        if (lightintensity < 300.0f) GPIOA->BSRR = GPIO_BSRR_BS7; else GPIOA->BSRR = GPIO_BSRR_BR7;

        delay(50000);
    }
}
