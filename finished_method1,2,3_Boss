/*
 * Final_Project.c
 *
 *  Created on: Sep 26, 2025
 *      Author: Acer
*/
#include <stdint.h>
#include <stdio.h>
#include <math.h>
#define STM32F411xE
#include "stm32f4xx.h"

/* --- Define สำหรับ LDR --- */
#define VREF        3.3f
#define VCC         3.3f
#define ADC_MAXRES  4095.0f
#define RX          10000.0f
#define SLOPE       -0.6875f
#define OFFSET      5.1276f

/* --- Define สำหรับ NTC --- */
#define R0          10000.0f
#define T0          298.15f   // 25 °C in Kelvin
#define BETA        3950.0f

char stringOut[50];

/* --- Delay --- */
static void delay(volatile uint32_t t) {
    while (t--) __NOP();
}

/* --- UART Tx String --- */
void vdg_UART_TxString(char strOut[]) {
    for (uint8_t idx = 0; strOut[idx] != '\0'; idx++) {
        while((USART2->SR & USART_SR_TXE) == 0);
        USART2->DR = strOut[idx];
    }
}

int main(void) {
    /* --- Enable Clocks --- */
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;  // GPIOA
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;  // GPIOB
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;   // ADC1
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN; // USART2

    /* --- Setup LEDs --- */
    GPIOA->MODER &= ~(3U << (2*6));
    GPIOA->MODER |=  (1U << (2*6)); // PA6 = Output (Red LED)

    GPIOB->MODER &= ~(3U << (2*6));
    GPIOB->MODER |=  (1U << (2*6)); // PB6 = Output (Green LED)

    GPIOA->MODER &= ~(3U << (2*7));
    GPIOA->MODER |=  (1U << (2*7)); // PA7 = Output (ไฟหน้า LDR)

    GPIOA->MODER &= ~(3U << (2*5));
    GPIOA->MODER |=  (1U << (2*5)); // PA5 = Output (ไฟเตือนอุณหภูมิ)

    /* --- Setup Buttons (PA10, PB3, PB5, PB4) --- */
    GPIOA->MODER &= ~(3U << (2*10)); // PA10 input
    GPIOB->MODER &= ~(3U << (2*3));  // PB3 input
    GPIOB->MODER &= ~(3U << (2*5));  // PB5 input
    GPIOB->MODER &= ~(3U << (2*4));  // PB4 input

    // Pull-up
    GPIOA->PUPDR |= (1U << (2*10));
    GPIOB->PUPDR |= (1U << (2*3));
    GPIOB->PUPDR |= (1U << (2*5));
    GPIOB->PUPDR |= (1U << (2*4));

    /* --- Setup ADC Pins --- */
    GPIOA->MODER |= (3U << (2*1)); // PA1 analog (LDR)
    GPIOA->MODER |= (3U << (2*0)); // PA0 analog (NTC)

    /* --- Setup ADC1 --- */
    ADC1->CR2 |= ADC_CR2_ADON;
    ADC1->SMPR2 |= ADC_SMPR2_SMP0 | ADC_SMPR2_SMP1; // sampling time
    ADC1->SQR1 &= ~ADC_SQR1_L; // one conversion

    /* --- Setup USART2 --- */
    GPIOA->MODER &= ~(GPIO_MODER_MODER2 | GPIO_MODER_MODER3);
    GPIOA->MODER |= (0b10 << GPIO_MODER_MODER2_Pos) | (0b10 << GPIO_MODER_MODER3_Pos);
    GPIOA->AFR[0] |= (0b0111 << GPIO_AFRL_AFSEL2_Pos) | (0b0111 << GPIO_AFRL_AFSEL3_Pos);

    USART2->CR1 |= USART_CR1_UE;
    USART2->CR1 &= ~USART_CR1_M;
    USART2->CR2 &= ~USART_CR2_STOP;
    USART2->BRR = 139; // 115200 @ 16MHz
    USART2->CR1 |= USART_CR1_TE;

    /* --- Enable FPU --- */
    SCB->CPACR |= (0b1111 << 20);
    __asm volatile("dsb");
    __asm volatile("isb");

    while (1) {
        /* --- Read Buttons --- */
        uint8_t btn_D2 = (GPIOA->IDR & (1U << 10)) ? 1 : 0; // PA10
        uint8_t btn_D3 = (GPIOB->IDR & (1U << 3))  ? 1 : 0; // PB3
        uint8_t btn_D4 = (GPIOB->IDR & (1U << 5))  ? 1 : 0; // PB5
        uint8_t btn_D5 = (GPIOB->IDR & (1U << 4))  ? 1 : 0; // PB4

        /* --- Function 3: LDR อ่านที่ PA1 --- */
        ADC1->SQR3 = 1; // channel 1 (PA1)
        ADC1->CR2 |= ADC_CR2_SWSTART;
        while (!(ADC1->SR & ADC_SR_EOC));
        float adc_voltage1 = (ADC1->DR * VREF) / ADC_MAXRES;
        float r_ldr = RX * adc_voltage1 / (VCC - adc_voltage1);
        float lightintensity = powf(10, SLOPE * log10f(r_ldr) + OFFSET);

        if (lightintensity < 300.0f) {
            GPIOA->BSRR = GPIO_BSRR_BS7;
        } else {
            GPIOA->BSRR = GPIO_BSRR_BR7;
        }

        /* --- Function 4: NTC อ่านที่ PA0 --- */
        ADC1->SQR3 = 0; // channel 0 (PA0)
        ADC1->CR2 |= ADC_CR2_SWSTART;
        while (!(ADC1->SR & ADC_SR_EOC));
        float adc_voltage0 = (ADC1->DR * VREF) / ADC_MAXRES;
        float r_ntc = RX * adc_voltage0 / (VCC - adc_voltage0);
        float temperature = ((BETA * T0) / (T0 * log(r_ntc/R0) + BETA)) - 273.15f;

        // แสดงอุณหภูมิแบบทศนิยม 1 ตำแหน่ง โดยไม่ใช้ %f
        int temp_int = (int)temperature;
        int temp_frac = (int)((temperature - temp_int) * 10);
        sprintf(stringOut, "Temperature = %d.%d Celsius\n", temp_int, temp_frac);
        vdg_UART_TxString(stringOut);

        // ไฟเตือนอุณหภูมิ >=28°C
        if (temperature >= 28.0f) {
            GPIOA->BSRR = GPIO_BSRR_BS5; // ไฟเตือนอุณหภูมิ
        } else {
            GPIOA->BSRR = GPIO_BSRR_BR5;
        }

        /* --- Function 1: ปุ่มควบคุมทิศทาง --- */
        if ((!btn_D2 && !btn_D3) || (!btn_D4 && !btn_D5)) {
            GPIOA->BSRR = GPIO_BSRR_BR6; // ปิด Red
            GPIOB->BSRR = GPIO_BSRR_BR6; // ปิด Green
        } else {
            if (!btn_D2) { // เดินหน้า
                GPIOB->BSRR = GPIO_BSRR_BS6;
            } else {
                GPIOB->BSRR = GPIO_BSRR_BR6;
            }

            if (!btn_D3) { // ถอยหลัง
                GPIOA->BSRR = GPIO_BSRR_BS6;
            } else {
                GPIOA->BSRR = GPIO_BSRR_BR6;
            }

            if (!btn_D4) { // เลี้ยวซ้าย
                GPIOB->BSRR = GPIO_BSRR_BS6;
                delay(300000);
                GPIOB->BSRR = GPIO_BSRR_BR6;
                delay(300000);
            }

            if (!btn_D5) { // เลี้ยวขวา
                GPIOA->BSRR = GPIO_BSRR_BS6;
                delay(300000);
                GPIOA->BSRR = GPIO_BSRR_BR6;
                delay(300000);
            }
        }

        delay(50000); // หน่วงเล็กน้อย
    }
}

